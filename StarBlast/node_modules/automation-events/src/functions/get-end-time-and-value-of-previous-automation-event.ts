import { getValueOfAutomationEventAtIndexAtTime } from 'automation-events/src/functions/get-value-of-automation-event-at-index-at-time';
import { isAnyRampToValueAutomationEvent } from 'automation-events/src/guards/any-ramp-to-value-automation-event';
import { isSetValueAutomationEvent } from 'automation-events/src/guards/set-value-automation-event';
import { isSetValueCurveAutomationEvent } from 'automation-events/src/guards/set-value-curve-automation-event';
import { IExtendedExponentialRampToValueAutomationEvent, IExtendedLinearRampToValueAutomationEvent } from 'automation-events/src/interfaces';
import { TPersistentAutomationEvent } from 'automation-events/src/types';

export const getEndTimeAndValueOfPreviousAutomationEvent = (
    automationEvents: TPersistentAutomationEvent[],
    index: number,
    currentAutomationEvent: TPersistentAutomationEvent,
    nextAutomationEvent: IExtendedExponentialRampToValueAutomationEvent | IExtendedLinearRampToValueAutomationEvent,
    defaultValue: number
): [number, number] => {
    return currentAutomationEvent === undefined
        ? [nextAutomationEvent.insertTime, defaultValue]
        : isAnyRampToValueAutomationEvent(currentAutomationEvent)
        ? [currentAutomationEvent.endTime, currentAutomationEvent.value]
        : isSetValueAutomationEvent(currentAutomationEvent)
        ? [currentAutomationEvent.startTime, currentAutomationEvent.value]
        : isSetValueCurveAutomationEvent(currentAutomationEvent)
        ? [
              currentAutomationEvent.startTime + currentAutomationEvent.duration,
              currentAutomationEvent.values[currentAutomationEvent.values.length - 1]
          ]
        : [
              currentAutomationEvent.startTime,
              getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)
          ];
};
